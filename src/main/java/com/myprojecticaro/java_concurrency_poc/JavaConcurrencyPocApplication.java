package com.myprojecticaro.java_concurrency_poc;

import com.myprojecticaro.java_concurrency_poc.callable.*;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.Supplier;

@SpringBootApplication
public class JavaConcurrencyPocApplication {

	public static void main(String[] args) {

		ExecutorService executor = Executors.newFixedThreadPool(2);

		try {

			/*
			 * - SimpleMessageCallable
			 * , teste simples de callable
			 */
			Future<String> messageFuture = executor.submit(new SimpleMessageCallable());

			System.out.println("SimpleMessageCallable result:");
			System.out.println(messageFuture.get());
			System.out.println();

			/*
			 * 2. SumCallable
			 * , Callable com estado
			 */
			Future<Integer> sumFuture = executor.submit(new SumCallable(10, 20));

			System.out.println("SumCallable result:");
			System.out.println(sumFuture.get());
			System.out.println();

			/*
			 * 3. DelayedCallable
			 * Simula processamento demorado
			 */
			Future<String> delayedFuture = executor.submit(new DelayedCallable(1000));

			System.out.println("DelayedCallable result:");
			System.out.println(delayedFuture.get());
			System.out.println();

			/*
			 * 4. FailingCallable
			 * Exceção capturada via ExecutionException
			 */
			Future<String> failingFuture = executor.submit(new FailingCallable());

			System.out.println("FailingCallable result:");
			try {
				System.out.println(failingFuture.get());
			} catch (ExecutionException e) {
				System.out.println("Exception FailingCallable from callable:");
				System.out.println(e.getCause().getMessage());
			}
			System.out.println();

			/*
			 * 5. SupplierCallable
			 * Callable reaproveitando e usanod o Supplier
			 */
			Supplier<String> supplier = () -> "Valor generated by Supplier";

			Future<String> supplierFuture = executor.submit(new SupplierCallable<>(supplier));

			System.out.println("SupplierCallable result:");
			System.out.println(supplierFuture.get());
			System.out.println();

			/*
             * 6. CounterCallable
             * Estado compartilhado com AtomicInteger
             */
            AtomicInteger counter = new AtomicInteger(0);

            Future<Integer> counterFuture1 = executor.submit(new CounterCallable(counter));

            Future<Integer> counterFuture2 = executor.submit(new CounterCallable(counter));

            System.out.println("CounterCallable results:");
            System.out.println(counterFuture1.get());
            System.out.println(counterFuture2.get());
            System.out.println("------------------------------------------------");

			/*
             * 7. UppercaseCallable
             * Transformação de dados
             */
            Future<String> uppercaseFuture = executor.submit(new UppercaseCallable("callable example"));

            System.out.println("UppercaseCallable result:");
            System.out.println(uppercaseFuture.get());
            System.out.println()
			

		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			executor.shutdown();
		}


	}

}
