package com.myprojecticaro.java_concurrency_poc;

import com.myprojecticaro.java_concurrency_poc.callable.*;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

@SpringBootApplication
public class JavaConcurrencyPocApplication {

    public static void main(String[] args) {

        ExecutorService executor = Executors.newFixedThreadPool(2);

        try {

            /*
             * 1. SimpleMessageCallable
             * Teste simples de Callable
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia SimpleMessageCallable");
            Future<String> messageFuture =
                    executor.submit(new SimpleMessageCallable());

            System.out.println("SimpleMessageCallable result:");
            System.out.println(messageFuture.get());
            System.out.println();
			System.out.println("Finaliza SimpleMessageCallable");
			System.out.println("********************************************************************");
            /*
             * 2. SumCallable
             * Callable com estado
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia SumCallable");
            Future<Integer> sumFuture = executor.submit(new SumCallable(10, 20));

            System.out.println("SumCallable result:");
            System.out.println(sumFuture.get());
            System.out.println();
			System.out.println("Finaliza SumCallable");
			System.out.println("********************************************************************");
            /*
             * 3. DelayedCallable
             * Simula processamento demorado
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia DelayedCallable");
            Future<String> delayedFuture = executor.submit(new DelayedCallable(1000));

            System.out.println("DelayedCallable result:");
            System.out.println(delayedFuture.get());
            System.out.println();
			System.out.println("Finaliza DelayedCallable");
			System.out.println("********************************************************************");
            /*
             * 4. FailingCallable
             * Exceção capturada via ExecutionException
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia FailingCallable");
            Future<String> failingFuture =
                    executor.submit(new FailingCallable());

            System.out.println("FailingCallable result:");
            try {
                System.out.println(failingFuture.get());
            } catch (ExecutionException e) {
                System.out.println("Exception from FailingCallable:");
                System.out.println(e.getCause().getMessage());
            }
            System.out.println();
			System.out.println("Finaliza FailingCallable");
			System.out.println("********************************************************************");
            /*
             * 5. SupplierCallable
             * Callable reutilizando Supplier
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia SupplierCallable");
            Supplier<String> supplier =
                    () -> "Value generated by Supplier";

            Future<String> supplierFuture =
                    executor.submit(new SupplierCallable<>(supplier));

            System.out.println("SupplierCallable result:");
            System.out.println(supplierFuture.get());
            System.out.println();

			System.out.println("Finaliza SupplierCallable");
			System.out.println("********************************************************************");
            /*
             * 6. CounterCallable
             * Estado compartilhado com AtomicInteger
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia CounterCallable");
            AtomicInteger counter = new AtomicInteger(0);

            Future<Integer> counterFuture1 =
                    executor.submit(new CounterCallable(counter));

            Future<Integer> counterFuture2 =
                    executor.submit(new CounterCallable(counter));

            System.out.println("CounterCallable results:");
            System.out.println(counterFuture1.get());
            System.out.println(counterFuture2.get());
            System.out.println();
			System.out.println("Finaliza CounterCallable");
			System.out.println("********************************************************************");
            /*
             * 7. UppercaseCallable
             * Transformação de dados
             */
			System.out.println("********************************************************************");
			System.out.println("Inicia UppercaseCallable");
            Future<String> uppercaseFuture = executor.submit(new UppercaseCallable("callable example"));

            System.out.println("UppercaseCallable result:");
            System.out.println(uppercaseFuture.get());
            System.out.println();

			System.out.println("Finaliza uppercaseFuture");
			System.out.println("********************************************************************");

            /*
             * 8. CancellableCallable
             * Cancelamento de task
             */

			System.out.println("********************************************************************");
			System.out.println("Inicia cancelFuture");

            Future<String> cancelFuture = executor.submit(new CancellableCallable());

            Thread.sleep(1200);

            System.out.println("Requesting task cancellation");
            boolean cancelled = cancelFuture.cancel(true);

            System.out.println("Cancel result: " + cancelled);
            System.out.println("Is cancelled: " + cancelFuture.isCancelled());
            System.out.println("Is done: " + cancelFuture.isDone());
            System.out.println();

			System.out.println("Finaliza cancelFuture");
			System.out.println("********************************************************************");

            /*
             * 9. SlowCallable
             * Observação do estado do Future
             */

			System.out.println("********************************************************************");
			System.out.println("Inicia slowFuture");

            Future<String> slowFuture = executor.submit(new SlowCallable());

            System.out.println("After submit");
            printState(slowFuture);

            Thread.sleep(500);

            System.out.println("While executing");
            printState(slowFuture);

            Thread.sleep(2000);

            System.out.println("After completion");
            printState(slowFuture);

            System.out.println("Result: " + slowFuture.get());

			System.out.println("Finaliza slowFuture");
			System.out.println("********************************************************************");


        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }

    private static void printState(Future<?> future) {
        System.out.println("isDone: " + future.isDone());
        System.out.println("isCancelled: " + future.isCancelled());
        System.out.println();
    }
}
